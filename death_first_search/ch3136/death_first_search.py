# <h1>Death First Search Implementation!!!</h1>
# <h2>Clark Hensley, ch3136</h2>

# <h3>Overview and Description</h3>
# <p>This is an implementation that solves the&nbsp;<a
#         href="https://www.codingame.com/ide/puzzle/death-first-search-episode-1">Death
#         First Search</a> game on <a
#         href="https://www.codingame.com">CodinGame.</a></p>
# <p>Death First Search is a game where you are some sort of systems
#     administrator, and a malicious actor, called the Bobnet, is attempting to
#     take over your system.</p>
# <p>The game requires the user to take in 3 lists of input: the <strong>nodes
#     </strong>in the network that Bobnet is attacking, the subset of those
#     nodes which are "<strong>exit</strong>" nodes, and thus could allow the
#     malicious actor to escape, and the <strong>links</strong> between these
#     nodes.</p>
# <p>In general, my approach to solving this problem resulted in forming the
#     input data into an <strong>edge-list vector</strong>. Based on this
#     vector, the program reads in the current position of the Bobnet each round
#     of play and removes the link between the Bobnet and the
#     closest&nbsp;<strong>exit</strong> node to it.</p>

# <h3>Legacy Entries generated by CodinGame</h3>
# <p>These imports were given by the base file. CodinGame uses
#     the&nbsp;<strong>sys </strong>python module to print to stderr, and
#     automatically offers you the&nbsp;<strong>math</strong> module. I did not
#     end up needing either of these, but I did not delete them, so they remain
#     here as legacy entries</p>
import sys
import math

# <p>This line, which is now a comment, was originally given to define the input
#     variables. I have since renamed these.</p>

# <p>n: the total number of nodes in the level, including the gateways l: the
#     number of links e: the number of exit gateways</p>

# <h3>Game Setup</h3>
# <p>Read in Game State and set up lists of
#     <strong>nodes</strong>,&nbsp;<strong>exit nodes</strong>,
#     and&nbsp;<strong>links</strong></p>
num_nodes: int
num_links: int
num_exits: int
i: int
# <p>The game gives the size of these three lists first</p>
num_nodes, num_links, num_exits = [int(i) for i in input().split()]
connections: list[tuple[int, int]] = list()
exits: list[int] = list()
for i in range(num_links):
    # <p>Add each edge to the&nbsp;<strong>edge-list vector</strong>. Because we
    #     can use Python's&nbsp;<span
    #         style="color: rgb(53, 152, 219);">in</span> key-word, we can treat
    #     these as un-directed edges, and not need to account for both the edge
    #     a --&gt; b and edge b --&gt; a. Instead, just the a --&gt; b case
    #     handles both.</p>
    node_from: int
    node_to: int
    node_from, node_to = [int(j) for j in input().split()]
    connections.append((node_from, node_to))
for i in range(num_exits):
    # <p>Add each&nbsp;<strong>exit node</strong> to a list of exits.</p>
    exit_index: int = int(input())  # the index of an exit node
    exits.append(exit_index)

# <h3>Main Game Loop</h3>
while True:
    # <p>If we ever are in a case where we do not directly remove a <strong>node
    #     </strong>that is being attacked by the Bobnet, we'll need to note that
    #     we should still print something for this turn.</p>
    printed: bool = False
    # <p>Each turn, we receive the position of the Bobnet attacker.</p>
    bobnet_position: int = int(input()) # The index of the node on which the Bobnet agent is positioned this turn

    # <p>The following line is again legacy code generated by CodinGame,
    #     discussing how to use python's&nbsp;<strong>sys</strong> module to
    #     debug. I did not remove it from my code, so it remains here as a
    #     legacy note.</p>
    # <p>Write an action using print To debug: print("Debug messages...",
    #     file=sys.stderr, flush=True)</p>

    # <p>Here, we note which <strong>connections</strong> are linked to
    #     an&nbsp;<strong>exit node.&nbsp;</strong>On Avery's recommendation,
    #     I've renamed this list to "exit_connections"</p>
    exit_index: int
    exit_connections: list[tuple[int, int]] = list()
    for exit_index in exits:
        exit_connections += [c for c in connections if exit_index in c]

    # <p>This is the key section. If the Bobnet is on a <strong>node
    #     </strong>that is an&nbsp;<strong>exit node</strong>, then we close the
    #     <strong>connection </strong>between the two</p>
    # <p><img src="death_first_search.png"></p>
    # <p>&nbsp;</p>
    # <p>This example screenshot from the game shows how it works:</p>
    # <ul>
    #     <li>The central blue nodes with the triangle symbol are
    #         the&nbsp;<strong>exit nodes.</strong></li>
    #     <li>The blue&nbsp;<strong>links&nbsp;</strong>between
    #         the&nbsp;<strong>exit nodes</strong> and others show that the link
    #         has been closed.</li>
    #     <li>The Bobnet attacker is in the top right circle of
    #         <strong>nodes</strong>, moving from the most-recently closed set
    #         of <strong>nodes </strong>to the next one to attempt to attack.
    #     </li>
    #     <li>This means, overall, that the program closes off the threatened
    #         <strong>nodes </strong>as the Bobnet moves around them.</li>
    # </ul>
    # <p>&nbsp;</p>
    key: int
    value: list[int]
    high_priority_connection: tuple[int, int]
    for high_priority_connection in exit_connections:
        if bobnet_position in high_priority_connection:
            print(f"{high_priority_connection[0]} {high_priority_connection[1]}")

            #

            # <p>Now, mark that we printed something, so that we don't print
            #     again in the next step</p>
            printed = True

            # <p>We can now break the loop</p>
            break


    # <p>If we did not directly remove a connection between the Bobnet's current
    #     position and an exit, we just remove the next connection with an Exit.
    # </p>
    # <p>In practice, in the challenges from the game, this never occurs. The
    #     game is structured in such a way that Bobnet seems to always be 1-node
    #     away, in order to ensure the player is using the most efficient
    #     solution.</p>
    # <p>If there were ever a case where this section was printed, at the
    #     moment, it just removes the numerically first high-priority
    #     connection. A possible improvement would be to perform some type of
    #     graph search to find which&nbsp;<strong>exit nodes</strong> are at the
    #     most risk, but that seems outside of the scope of this project.</p>
    if not printed:
        print(f"{exit_connections[0][0]} {exit_connections[0][1]}")
